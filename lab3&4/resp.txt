1 - 
	O programa primeiramente registrou as funções intHandler e quitHandler como as funções de tratamento para os sinais SIGINT e SIGQUIT respectivamente. SIGINT equivale ao Ctrl-c e SIGQUIT ao Ctrl-\. Também imprimiu os endereços das funções manipuladoras prévias, que não existiam, e portanto imprimiu NIL. Depois, entrou num loop infinito. Quando então apertamos Ctrl-c, o programa é desviado para a função intHandler, que imprime "Você pressionou Ctrl-C (2)", porque 2 é o inteiro do sinal crtl-c. Já quando apertamos crtl-\ a handler quitHandler, que termina o processo com exit(0).
	Sem os comandos signal, ao apertarmos crtl-c no terminal encerramos o processo, o que é resultado da função de tratamento de sinais padrão.

2 - Não conseguimos interceptar o sinal KILL com nosso handler. Fizemos um mesmo teste com o sinal SIGINT e consiguimos interceptar. Isso acontece porque o sinal KILL, por padrão do UNIX, não pode ser interceptado, por ser importante podermos interromper qualquer processo.

3- O programa principal cria um processo filho, que executará um pequeno programa que imprime uma mensagem, dorme por n segundos e depois imprime outra. Enquanto isso, o processo pai espera por t tempo, passado como argumento na linha de comando. Caso passe t tempo e o processo filho ainda não tiver terminado, ou seja, o pequeno programa não tiver reacordado, o processo pai mata o processo filho e imprime uma mensagem de acordo. Caso não, o pequeno programa consegue imprimir sua segunda mensagem, mostrando que acordou, e o processo filho termina normalmente. Ao ser morto pelo pai ou terminar normalmente, o filho manda o sinal SIGCHLD, que é tratado no processo pai pela funçao childhandler.
